<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>Autobiography STT + SSE í…ŒìŠ¤íŠ¸ (VAD ì ìš©)</title>
    <style>
        body { font-family: sans-serif; max-width: 700px; margin: 2rem auto; }
        #messages { border: 1px solid #ccc; padding: 1rem; height: 300px; overflow-y: auto; }
        .ai    { text-align: left;  color: #090; }
        .user  { text-align: right; color: #006; }
        .error { text-align: left; color: #f66; }
        .system { text-align: center; color: #888; font-style: italic; }
        button, input { padding: .5rem; margin: .5rem 0; width: 100%; box-sizing: border-box; }

        #audioLevel {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        #audioLevelBar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            width: 0%;
            transition: width 0.1s ease;
        }

        .settings { background: #f9f9f9; padding: 1rem; border-radius: 5px; margin: 1rem 0; }
        .settings label { display: block; margin: .5rem 0; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body>
<h2>Autobiography STT + SSE í…ŒìŠ¤íŠ¸ (VAD ì ìš©)</h2>
<div id="messages"></div>

<div class="settings">
    <label><input type="checkbox" id="enableVAD" checked /> VAD (ìŒì„± í™œë™ ê°ì§€) ì‚¬ìš©</label>
    <label>ìŒì„± ê°ì§€ ì„ê³„ê°’: <span id="thresholdValue">0.01</span>
        <input type="range" id="threshold" min="0.001" max="0.1" step="0.001" value="0.01" />
    </label>
    <label>ë¬´ìŒ í—ˆìš© ì‹œê°„ (ì´ˆ): <span id="silenceTimeValue">10</span>
        <input type="range" id="silenceTime" min="1" max="30" step="1" value="10" />
    </label>
</div>

<div id="audioLevel">
    <div id="audioLevelBar"></div>
</div>

<input type="text" id="properInput" placeholder="ê³ ìœ ëª…ì‚¬ë¥¼ ì‰¼í‘œë¡œ êµ¬ë¶„í•´ ì…ë ¥í•˜ì„¸ìš”" />
<button id="startBtn">â–¶ ì—í”¼ì†Œë“œ ì‹œì‘</button>
<button id="recordBtn" disabled>ğŸ™ï¸ ë…¹ìŒ ì‹œì‘</button>
<button id="stopBtn" disabled>â¹ï¸ ë…¹ìŒ ì¤‘ì§€</button>
<button id="nextQuestionBtn" disabled>â–¶ ë‹¤ìŒ ì§ˆë¬¸ ë°›ê¸°</button>

<script>
    const msgs = document.getElementById('messages');
    const properInput = document.getElementById('properInput');
    const startBtn = document.getElementById('startBtn');
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const nextQuestionBtn = document.getElementById('nextQuestionBtn');
    const enableVAD = document.getElementById('enableVAD');
    const threshold = document.getElementById('threshold');
    const thresholdValue = document.getElementById('thresholdValue');
    const silenceTime = document.getElementById('silenceTime');
    const silenceTimeValue = document.getElementById('silenceTimeValue');
    const audioLevelBar = document.getElementById('audioLevelBar');

    let sessionId = crypto.randomUUID();
    let episodeId = 1;
    let chunkIndex = 0;
    let source, mediaRecorder, stream, chunkTimer, audioContext, analyser;
    let isRecording = false;
    let currentAudioLevel = 0;
    let lastSpeechTime = 0;
    let voiceDetected = false;

    threshold.oninput = () => thresholdValue.textContent = threshold.value;
    silenceTime.oninput = () => silenceTimeValue.textContent = silenceTime.value;

    function append(txt, cls='ai') {
        const d = document.createElement('div');
        d.className = cls;
        d.textContent = txt;
        msgs.appendChild(d);
        msgs.scrollTop = msgs.scrollHeight;
    }

    function analyzeAudio() {
        if (!analyser) return;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(dataArray);
        let sum = dataArray.reduce((acc,v) => acc + v*v, 0);
        const rms = Math.sqrt(sum / dataArray.length);
        currentAudioLevel = rms / 255;
        audioLevelBar.style.width = (currentAudioLevel*100) + '%';
        const currentThreshold = parseFloat(threshold.value);
        const currentSilenceTime = parseFloat(silenceTime.value)*1000;
        if (currentAudioLevel > currentThreshold) {
            lastSpeechTime = Date.now();
            if (!voiceDetected) { voiceDetected = true; append('ğŸ¤ ìŒì„± ê°ì§€ë¨','system'); }
        } else if (voiceDetected && Date.now() - lastSpeechTime > currentSilenceTime) {
            voiceDetected = false; append('ğŸ”‡ ìŒì„± ì¤‘ë‹¨ ê°ì§€','system');
        }
        if (isRecording) requestAnimationFrame(analyzeAudio);
    }

    startBtn.onclick = () => {
        source = new EventSource(
            `http://localhost:8080/api/conversation/stream?sessionId=${sessionId}`
        );
        source.addEventListener('question', e => {
            const { text } = JSON.parse(e.data);
            append(`AI: ${text}`,'ai');
            recordBtn.disabled = false;
            nextQuestionBtn.disabled = false;
        });
        source.addEventListener('partialTranscript', e => {
            const { chunkIndex, text } = JSON.parse(e.data);
            append(`(${chunkIndex}) ìŒì„± ì¸ì‹ ì¤‘â€¦ ${text}`,'user');
        });
        source.addEventListener('finalTranscript', e => {
            const { chunkIndex, text } = JSON.parse(e.data);
            append(`âœ… ìµœì¢… ì¸ì‹ (#${chunkIndex}): ${text}`,'user');
            // STT ê²€í†  í›„ í™•ì •
            nextQuestionBtn.disabled = false;
        });
        source.addEventListener('error', () => { append('âŒ SSE ì—ëŸ¬','error'); source.close(); });
        append(`ì„¸ì…˜ ì—´ë¦¼: ${sessionId}`,'system');
        startBtn.disabled = true;
    };

    recordBtn.onclick = async () => {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ audio:true });
            audioContext = new (window.AudioContext||window.webkitAudioContext)();
            const mic = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser(); mic.connect(analyser);
            isRecording = true; voiceDetected = false; lastSpeechTime = Date.now();
            startChunkRecorder(); analyzeAudio();
            append('ğŸ™ï¸ ë…¹ìŒ ì‹œì‘ (ìŒì„± í™œë™ ê°ì§€)','system');
            recordBtn.disabled = true; stopBtn.disabled = false;
        } catch(err){ append('âŒ ë§ˆì´í¬ ì˜¤ë¥˜: '+err.message,'error'); }
    };

    stopBtn.onclick = () => {
        isRecording = false; voiceDetected = false; clearTimeout(chunkTimer);
        if(mediaRecorder?.state==='recording') mediaRecorder.stop();
        stream?.getTracks().forEach(t=>t.stop());
        audioContext?.close(); audioContext = analyser = null;
        audioLevelBar.style.width = '0%';
        append('ğŸ”Š ë…¹ìŒ ì¤‘ì§€','user');
        stopBtn.disabled = true; recordBtn.disabled = false;
    };

    function startChunkRecorder() {
        mediaRecorder = new MediaRecorder(stream,{ mimeType:'audio/webm;codecs=opus' });
        mediaRecorder.ondataavailable = async e => {
            if(!e.data||e.data.size<1000){ chunkIndex++; append(`ğŸ§¹ ë¬´ìŒ ì²­í¬ ë¬´ì‹œ (size=${e.data.size})`,'system'); return; }
            const form = new FormData();
            form.append('sessionId',sessionId);
            form.append('chunkIndex',chunkIndex);
            form.append('audio',e.data,'audio.webm');
            form.append('finalTranscript','true');
            form.append('audioLevel',currentAudioLevel.toFixed(3));
            if(properInput.value.trim()) form.append('customProperNouns',properInput.value.trim());
            append(`ğŸ“¤ ì²­í¬ #${chunkIndex} ì „ì†¡ì¤‘...`,'system');
            chunkIndex++;
            try {
                await axios.post('http://localhost:8080/api/stt/chunk',form,{ timeout:60000 });
            } catch(err){ append('âŒ STT ì˜¤ë¥˜: '+err.message,'error'); }
        };
        mediaRecorder.onstop = () => { if(isRecording) startChunkRecorder(); };
        mediaRecorder.start();
        chunkTimer = setTimeout(()=>{ if(mediaRecorder.state==='recording') mediaRecorder.stop(); },6000);
    }

    nextQuestionBtn.onclick = async () => {
        nextQuestionBtn.disabled = true;
        try {
            await axios.post('http://localhost:8080/api/conversation/next', null, { params:{ sessionId } });
        } catch(err){ append('âŒ ë‹¤ìŒ ì§ˆë¬¸ ìš”ì²­ ì˜¤ë¥˜: '+err.message,'error'); nextQuestionBtn.disabled = false; }
    };
</script>
</body>
</html>
